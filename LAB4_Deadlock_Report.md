<h1 style="text-align:center"> LAB4 死锁实验 </h1>
<h4 style="text-align:center"> 14353059 冯佳纯 2014M1班 </h4>

<br> </br>
##  1.  死锁实验截图

&emsp;&emsp;这一次按照ppt实现代码以后，运行程序，但是久久等不到死锁，因此就更改了一下代码。改了以后，在大概程序运行十几二十次以后，就产生死锁了。代码与结果如下：
![Alt text](./result.png)

&emsp;&emsp;这次更改代码的地方就是让每个实例在申请资源的时候，先等待一段之间，再去申请，也就是先占有自己实例的资源久一点，这样容易在还没有来得及申请另一个实例的时候就被剥夺cpu。然后另一个实例在占有自己的实例资源的时候，想要申请，却陷入循环等待，就产生了死锁。
![Alt text](./code.png)



<br><br>
## 2. 产生死锁的四个条件
####  1. 资源互斥互斥
&emsp;&emsp;一个资源每次只能给一个进程使用，这样的话，当有其他进程想要访问使用该资源的时候，就会被阻塞。
#### 2. 非抢占式
&emsp;&emsp;资源必须是非抢占式的，即资源申请者不能强行的从资源占有者手中夺取资源，只有等待资源占有者释放后才可使用。 
####  3. 占有且等待
&emsp;&emsp;一个资源若是处于申请其他资源而被阻塞的过程，则他需要等待，并且不会释放已经占有的资源。
####   4. 无限循环
&emsp;&emsp;死锁的形成，必然会造成一个资源申请的环形回路，造成无限循环与等待。

<br><br>

## 3. 此次实验产生死锁的原因
&emsp;&emsp; 此次试验中，类A和类B的代码都加了`synchronized`的关键字，使得被加了关键字部分的代码或者方法在同一时刻只能有最大一个线程来执行。而当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。
&emsp;&emsp; 因此，实验中，我们让线程`t`的`run`函数执行实例`a`的`last`方法，并且在主类的方法中得到count次后让a的methodA方法执行b的last方法，这样的话，当线程t被调度的时候，就很有可能碰到实例a在执行但是还没有得到b资源就被抢占了cpu，轮到了线程t的时候，因为资源b没有被占有，就申请得到了资源b，想要申请资源a，却因为还没有被释放，就陷入了等待，而a再次运行的时候，由于资源b已经被占有了，也陷入等待，形成资源申请的环形回路，就造成了死锁。

